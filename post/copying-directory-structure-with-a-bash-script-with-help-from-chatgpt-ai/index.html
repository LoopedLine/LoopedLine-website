<!DOCTYPE html>
<html lang="en-us">
    <head>
        
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Copying Directory Structure With a Bash Script - With Help From ChatGPT AI</title>
        
                
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Raleway">

        
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css" crossorigin="anonymous">

        
        

        
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css" integrity="sha512-+4zCK9k+qNFUR5X+cKL9EIR+ZOhtIloNl9GIKS57V1MyNsYpYcUrUeQc9vNfzsWfV28IaLL3i96P9sdNyeRssA==" crossorigin="anonymous" />

        <style>

            html body {
                font-family: 'Raleway', sans-serif;
                background-color: lightgray;
            }

            :root {
                --accent: purple;
                --border-width:  5px ;
            }

        </style>

        
        <link rel="stylesheet" href="https://loopedline.com/css/main.css">
        <link rel="stylesheet" href="https://loopedline.com/css/custom.css">

        
        
                
        

        
        

        
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

        
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>

        
        <script>$(document).on('click', function() { $('.collapse').collapse('hide'); })</script>
        <meta name="generator" content="Hugo 0.92.2" />
        
    

    

    
        <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    

        
    </head>

    <body>
        
        <nav class="navbar navbar-default navbar-fixed-top">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand visible-xs" href="#">Copying Directory Structure With a Bash Script - With Help From ChatGPT AI</a>
                    <button class="navbar-toggle" data-target=".navbar-collapse" data-toggle="collapse">
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                </div>
                <div class="collapse navbar-collapse">
                    
                        <ul class="nav navbar-nav">
                            
                                <li><a href="https://loopedline.com/">Home</a></li>
                            
                                <li><a href="https://loopedline.com/about/">About</a></li>
                            
                                <li><a href="https://loopedline.com/post/build/">Build</a></li>
                            
                                <li><a href="https://loopedline.com/post/learn/">Learn</a></li>
                            
                        </ul>
                    
                    
                        <ul class="nav navbar-nav navbar-right">
                            
                                <li class="navbar-icon"><a href="https://github.com/LoopedLine/"><i class="fab fa-github"></i></a></li>
                            
                                <li class="navbar-icon"><a href="https://page.loopedline.com/contact/"><i class="fas fa-envelope"></i></a></li>
                            
                        </ul>
                    
                </div>
            </div>
        </nav>


<main>

    
    <div>
        <h2>Copying Directory Structure With a Bash Script - With Help From ChatGPT AI</h2>
        











    <p>Published: 2024 January 22</p>




        
<a href="https://loopedline.com/tags/system-administration"><kbd class="item-tag">system administration</kbd></a>

<a href="https://loopedline.com/tags/linux"><kbd class="item-tag">Linux</kbd></a>

<a href="https://loopedline.com/tags/bash"><kbd class="item-tag">Bash</kbd></a>

<a href="https://loopedline.com/tags/shell-script"><kbd class="item-tag">shell script</kbd></a>

<a href="https://loopedline.com/tags/software-development"><kbd class="item-tag">software development</kbd></a>

<a href="https://loopedline.com/tags/artificial-intelligence"><kbd class="item-tag">artificial intelligence</kbd></a>


    </div>

    
    <div align="start" class="content"><!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h1 id="introduction">Introduction</h1>
<p>In this post we&rsquo;ll create a <a href="https://loopedline.com/post/bash-and-the-linux-shell-topic/">Bash</a> command for copying the directory structure of one directory into another directory using a Bash script - and we&rsquo;ll use <a href="https://chat.openai.com/">ChatGPT</a> to generate the script.</p>
<h1 id="chatgpt-conversation">ChatGPT Conversation</h1>
<hr>
<p><strong>Our Prompt</strong></p>
<p>Write a Bash command to recursively copy the directory structure of one directory to another directory.</p>
<p><strong>ChatGPT&rsquo;s Response</strong></p>
<blockquote>
<p>To recursively copy just the directory structure (without copying the actual files), you can use the <strong>`find`</strong> command in combination with <strong>`mkdir -p`</strong> and some text manipulation. Here&rsquo;s how you can do it:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">bash
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">cd /path/to/source_directory
find . -type d -exec mkdir -p /path/to/destination_directory/<span style="color:#f92672">{}</span> <span style="color:#ae81ff">\;</span>
</code></pre></div><p>Here&rsquo;s what this command does:</p>
<ol>
<li><strong>`cd /path/to/source_directory`</strong>: Navigate to the directory whose structure you want to copy.</li>
<li><strong>`find . -type d`</strong>: This finds all directories (<strong>`-type d`</strong>) starting from the current directory (.).</li>
<li><strong>`-exec mkdir -p /path/to/destination_directory/{} ;`</strong>: For each directory found, it creates the corresponding directory structure in the destination directory.</li>
</ol>
<p>Make sure to replace <strong>`/path/to/source_directory`</strong> with the path of the directory whose structure you want to copy and <strong>`/path/to/destination_directory`</strong> with the path where you want to replicate the directory structure.</p>
</blockquote>
<p>That&rsquo;s not a bad response.  It doesn&rsquo;t handle sub-directories that have a space in the name, but it&rsquo;s a good place to start.  Let&rsquo;s give it a chance to fix that issue.</p>
<hr>
<p><strong>Our Prompt</strong></p>
<p>Can you alter this to handle directories with spaces in their names?</p>
<p><strong>ChatGPT&rsquo;s Response</strong></p>
<blockquote>
<p>Certainly! To handle directories with spaces in their names, you can modify the command to properly quote the directory names. Here&rsquo;s an updated version:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">bash
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">cd <span style="color:#e6db74">&#34;/path/to/source_directory&#34;</span>
find . -type d -print0 | <span style="color:#66d9ef">while</span> IFS<span style="color:#f92672">=</span> read -r -d <span style="color:#e6db74">&#39;&#39;</span> dir; <span style="color:#66d9ef">do</span>
    mkdir -p <span style="color:#e6db74">&#34;/path/to/destination_directory/</span><span style="color:#e6db74">${</span>dir#./<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>
<span style="color:#66d9ef">done</span>
</code></pre></div><p>Here&rsquo;s the breakdown of the changes:</p>
<ol>
<li>
<p>The <strong>`-print0`</strong> option for <strong>`find`</strong> and <strong>`-d &lsquo;'`</strong> option for <strong>`read`</strong> use null characters (<strong>`\0`</strong>) as the delimiter instead of newline characters. This helps in handling file or directory names containing spaces or other special characters.</p>
</li>
<li>
<p><strong>`${dir#./}`</strong> removes the leading <strong>`./`</strong> from the directory path, ensuring that the structure is replicated correctly in the destination directory.</p>
</li>
</ol>
<p>Remember to replace <strong>`/path/to/source_directory`</strong> with the path to your source directory and <strong>`/path/to/destination_directory`</strong> with the path where you want the directory structure to be copied.</p>
</blockquote>
<p>That seems to give us what we&rsquo;re wanting, so let&rsquo;s look at the command more closely.</p>
<hr>
<h1 id="the-command">The Command</h1>
<p>Let&rsquo;s break down this command to understand what it&rsquo;s doing.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">find . -type d -print0 | <span style="color:#66d9ef">while</span> IFS<span style="color:#f92672">=</span> read -r -d <span style="color:#e6db74">&#39;&#39;</span> dir; <span style="color:#66d9ef">do</span>
    mkdir -p <span style="color:#e6db74">&#34;/path/to/destination_directory/</span><span style="color:#e6db74">${</span>dir#./<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>
<span style="color:#66d9ef">done</span>
</code></pre></div><p>There are three basic components to this command:</p>
<ol>
<li>
<p><code>find...</code></p>
</li>
<li>
<p><code>|</code></p>
</li>
<li>
<p><code>while... do... done</code></p>
</li>
</ol>
<p>Let&rsquo;s look at each in turn.</p>
<h2 id="find-command">find command</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">find . -type d -print0 ...
</code></pre></div><p><code>find</code> - &ldquo;Find files or directories under the given directory tree, recursively.&rdquo; <em>(From <a href="https://tldr.inbrowser.app/pages/common/find">tldr pages</a>.)</em></p>
<ul>
<li>
<p><code>.</code> - Tells <em>find</em> to search the current working directory.</p>
</li>
<li>
<p><code>-type d</code> - &ldquo;File is of type&hellip; directory.&rdquo; <em>(From <a href="https://man7.org/linux/man-pages/man1/find.1.html">manual pages for find</a>.)</em></p>
</li>
<li>
<p><code>-print0</code> - &ldquo;Print the full file name on the standard output, followed by a null character (instead of the newline character that <em>-print</em> uses). This allows file names that contain newlines or other types of white space to be correctly interpreted by programs that process the find output.&rdquo; <em>(From <a href="https://man7.org/linux/man-pages/man1/find.1.html">manual pages for find</a>.)</em></p>
</li>
</ul>
<p><code>find . -type d -print0</code> - Put together, this command finds files of type <em>directory</em> in the current working directory and prints the full name to standard output followed by a null character.</p>
<h2 id="pipe-operator-">pipe operator (|)</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">... | ...
</code></pre></div><p><code>|</code> - The pipe operator &ldquo;connects the STDOUT (standard output) file descriptor of the first process to the STDIN (standard input) of the second. What happens then is that when the first process writes to its STDOUT, that output can be immediately read (from STDIN) by the second process.&rdquo; <em>(From <a href="https://stackoverflow.com/questions/9834086/what-is-a-simple-explanation-for-how-pipes-work-in-bash/9834118#9834118">this StackOverflow answer</a>.)</em></p>
<h2 id="while-loop">while loop</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">... <span style="color:#66d9ef">while</span> IFS<span style="color:#f92672">=</span> read -r -d <span style="color:#e6db74">&#39;&#39;</span> dir; <span style="color:#66d9ef">do</span>
    mkdir -p <span style="color:#e6db74">&#34;/path/to/destination_directory/</span><span style="color:#e6db74">${</span>dir#./<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>
<span style="color:#66d9ef">done</span>
</code></pre></div><p><code>while [TEST-CONDITION]; do [CONSEQUENT-COMMANDS]; done</code> - This is the basic while loop structure in Bash. <em>(From the <a href="https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html#index-while">Bash Reference Manual</a>.)</em></p>
<p>We&rsquo;ll look at the <em>test condition</em> and the <em>consequent command</em> separately.</p>
<h3 id="while-loop-test-condition">while loop test condition</h3>
<p>The test condition of <code>IFS= read -r -d '' dir</code> has two components:</p>
<ol>
<li>Redefining <strong>IFS</strong>, and</li>
<li>The <strong>read</strong> command.</li>
</ol>
<h4 id="redefining-ifs">Redefining IFS</h4>
<ul>
<li>
<p><code>IFS</code> - (Internal Field Separator) &ldquo;A list of characters that separate fields; used when the shell splits words as part of expansion.&rdquo; <em>(From the <a href="https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html#index-IFS">Bash Reference Manual for IFS</a>.)</em></p>
<ul>
<li><code>IFS=</code> - This sets the value of the IFS (Internal Field Separator) variable to Null, which when used here with the <em>read</em> command causes it &ldquo;to preserve leading and trailing white space&rdquo; <em>(according to <a href="https://stackoverflow.com/questions/26479562/what-does-ifs-do-in-this-bash-loop-cat-file-while-ifs-read-r-line-do/26480210#26480210">this StackOverflow answer</a>)</em>.  And because it is not terminated with a semicolon, &ldquo;redefines [the IFS variable] only for the read invocation&rdquo; <em>(according to <a href="https://unix.stackexchange.com/questions/18886/why-is-while-ifs-read-used-so-often-instead-of-ifs-while-read/18889#18889">this StackOverflow answer</a>)</em>.</li>
</ul>
</li>
</ul>
<h4 id="read-comand">read comand</h4>
<p><code>read [OPTION(S)] [NAME(S)]</code> - This is a basic read command form in Bash.  <em>(From the <a href="https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html#index-read">Bash Reference Manual for Bash Builtin Commands</a>.)</em></p>
<ul>
<li>
<p><code>read</code> - &ldquo;Shell builtin for retrieving data from standard input.&rdquo; <em>(From <a href="https://tldr.inbrowser.app/pages/common/read">tldr pages</a>.)</em></p>
</li>
<li>
<p><code>-r</code> - &ldquo;If this option is given, backslash does not act as an escape character. The backslash is considered to be part of the line.&rdquo; <em>(From the <a href="https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html#index-read">Bash Reference Manual for Bash Builtin Commands</a>.)</em></p>
</li>
<li>
<p><code>-d [DELIM]</code> - &ldquo;The first character of <em>delim</em> is used to terminate the input line, rather than newline. If <em>delim</em> is the empty string, <em>read</em> will terminate a line when it reads a NUL character.&rdquo;  <em>(From the <a href="https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html#index-read">Bash Reference Manual for Bash Builtin Commands</a>.)</em></p>
<ul>
<li><code>-d ''</code> - Per the above specification, this argument instructs <em>read</em> to terminate a line when it reads a NUL character.</li>
</ul>
</li>
<li>
<p><code>read ... [NAME(S)]</code> - &ldquo;One line is read from the standard input, &hellip; split into words&hellip;, and the first word is assigned to the first name, the second word to the second name, and so on.&rdquo;  <em>(From the <a href="https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html#index-read">Bash Reference Manual for Bash Builtin Commands</a>.)</em></p>
<ul>
<li><code>read ... dir</code> - Per the above specification, this portion takes the first word split by <em>read</em> and assigns it to the variable <strong>dir</strong>.</li>
</ul>
</li>
</ul>
<p><code>IFS= read -r -d '' dir</code> - Put together, this command sets the <em>IFS</em> variable to <em>Null</em> in the scope of the <em>read</em> command, and <em>read</em> then splits the standard input into &ldquo;words&rdquo; when it finds a <em>Null</em>, treating backslash and newline as normal characters that are part of the &ldquo;word&rdquo;.  The <em>read</em> command then assigns the word to the <strong>dir</strong> variable.</p>
<h3 id="consequent-commands-in-the-while-loop">consequent commands in the while loop</h3>
<p>The consequent command of <code>mkdir -p &quot;/path/to/destination_directory/${dir#./}&quot;</code> is last part of the overall command.</p>
<p><code>mkdir [OPTION(S)] [NAME(S)]</code> - This is a basic mkdir command form.  <em>(From the <a href="https://www.gnu.org/software/coreutils/manual/html_node/mkdir-invocation.html#mkdir-invocation">GNU Coreutils Manual for mkdir</a>.)</em></p>
<ul>
<li>
<p><code>mkdir</code> - &ldquo;Creates directories with the specified names.&rdquo;  <em>(From the <a href="https://www.gnu.org/software/coreutils/manual/html_node/mkdir-invocation.html#mkdir-invocation">GNU Coreutils Manual for mkdir</a>.)</em></p>
</li>
<li>
<p><code>-p</code> -   This option &ldquo;makes any missing parent directories for each argument&rdquo;.  <em>(From the <a href="https://www.gnu.org/software/coreutils/manual/html_node/mkdir-invocation.html#mkdir-invocation">GNU Coreutils Manual for mkdir</a>.)</em></p>
</li>
<li>
<p><code>${[PARAMETER]}</code> - This is &ldquo;the basic form of parameter expansion&rdquo; in Bash.    <em>(From the <a href="https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html#Shell-Parameter-Expansion">Bash Reference Manual for Shell Parameter Expansion</a>.)</em></p>
<ul>
<li>
<p><code>${dir}</code> - Per the above definition, this portion of the [NAME] field in the <em>mkdir</em> command substitutes the directory string from the earlier <em>read</em> command.</p>
</li>
<li>
<p><code>${dir#./}</code> - This line, filled with special characters, proved somewhat obscure and difficult to search.  We turned again to ChatGPT for an explanation.</p>
</li>
</ul>
</li>
</ul>
<hr>
<p><strong>ChatGPT&rsquo;s Response</strong></p>
<blockquote>
<p>Let&rsquo;s break down <strong>`${dir#./}`</strong>:</p>
<ul>
<li>
<p><strong>`${dir}`</strong>: This is the variable representing each directory found by the <strong>`find`</strong> command during each iteration of the loop.</p>
</li>
<li>
<p><strong>`#./`</strong>: This is a parameter expansion syntax in Bash. <strong>`${dir#./}`</strong> removes the shortest match of <strong>`./`</strong> (if it exists) from the beginning of the <strong>`$dir`</strong> variable. This is used to ensure that the directory structure is replicated correctly in the destination directory without including the leading <strong>`./`</strong>.</p>
</li>
</ul>
<p>So, for example, if <strong>`dir`</strong> is <strong>`./path/to/source_directory/subdir`</strong>, <strong>`${dir#./}`</strong> would result in <strong>`path/to/source_directory/subdir`</strong>. This ensures that the directory structure is maintained in the destination directory without creating unnecessary subdirectories starting with <strong>`./`</strong>.</p>
<p>In summary, <strong>`${dir#./}`</strong> is a way to remove the leading <strong>`./`</strong> from the directory path obtained from the <strong>`find`</strong> command, ensuring that the structure is replicated correctly in the destination directory.</p>
</blockquote>
<hr>
<p>That seems to comport with the <a href="https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html#Shell-Parameter-Expansion">Bash Reference Manual for Shell Parameter Expansion</a> section dealing with <code>${parameter#word}</code>, which states that &ldquo;the <em>word</em> is expanded to produce a pattern&hellip; If the pattern matches the beginning of the expanded value of <em>parameter</em>, then the result of the expansion is the expanded value of <em>parameter</em> with the shortest matching pattern (the ‘#’ case)&hellip; deleted.&rdquo;</p>
<p>Based on that, it appears that the line <code>${dir#./}</code> is a standard shell parameter expansion where the leading <em>./</em> characters, if any, are removed.</p>
<p><code>mkdir -p &quot;/path/to/destination_directory/${dir#./}&quot;</code> - Taken together, the consequent command makes a directory (and all required parent directories) at the path specified, and appends the directory names from the earlier <em>find</em> command, ignoring any leading <em>./</em> characters.</p>
<h2 id="the-assembled-command">The assembled command</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">find . -type d -print0 | <span style="color:#66d9ef">while</span> IFS<span style="color:#f92672">=</span> read -r -d <span style="color:#e6db74">&#39;&#39;</span> dir; <span style="color:#66d9ef">do</span>
    mkdir -p <span style="color:#e6db74">&#34;/path/to/destination_directory/</span><span style="color:#e6db74">${</span>dir#./<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>
<span style="color:#66d9ef">done</span>
</code></pre></div><p>Taken all together, this command will:</p>
<ol>
<li><strong>find</strong> files of type <em>directory</em> in the current working directory and prints the full name to standard output followed by a null character, which is then</li>
<li><strong>piped</strong> to the next command, which is a</li>
<li><strong>while loop</strong> that separates those full names (by the inserted null character) and creates a matching directory at the specified target location.</li>
</ol>
<h1 id="conclusion">Conclusion</h1>
<p>Using ChatGPT to build the baseline Bash command was much faster than attempting to piece it together manually.  Trial and error was involved, but that would be true for a script built manually as well.  And when there were questions about a portion of command, ChatGPT was helpful at explaining that portion.</p>
<p>We have the command we&rsquo;re looking for and, thanks to ChatGPT, saved a lot of time in building it.</p>
<!-- raw HTML omitted -->
</div>

    
    
    
        <h4 class="page-header">Related</h4>
         <div class="item">



    
    
    <h4 id="listpage-item"><a href="/post/setting-up-a-raspberry-pi-as-a-linux-print-server-with-cups/">Setting Up a Raspberry Pi as a Linux Print Server with CUPS</a></h4>



    

    
    
    

    
    
    

    
    

    <p>
        Published: 2024 January 19
        
    </p>



</div>
  <div class="item">



    
    
    <h4 id="listpage-item"><a href="/post/setting-up-a-raspberry-pi-zero-2-w-with-ubuntu-server/">Setting Up a Raspberry Pi Zero 2 W with Ubuntu Server</a></h4>



    

    
    
    

    
    
    

    
    

    <p>
        Published: 2024 January 04
        
    </p>



</div>
  <div class="item">



    
    
    <h4 id="listpage-item"><a href="/post/bash-and-the-linux-shell-basic-terminal-command-quick-reference/">Bash and The Linux Shell - Basic Terminal Command Quick Reference</a></h4>



    

    
    
    

    
    
    

    
    

    <p>
        Published: 2023 October 18
        
    </p>



</div>
 
    

</main>



        <footer>
            <p class="copyright text-muted">© LoopedLine 2020-2024. All rights reserved. Powered by <a href="https://gohugo.io">Hugo</a> and <a href="https://github.com/calintat/minimal">Minimal</a> and <a href="https://loopedline.com/bespoke/main.html">Bespoke</a>.</p>

        </footer>

        
        
    </body>

</html>